
# 创建进程

## fork()

- 创建子进程
- 远程序以fork()函数出现的行为分界
  - fork之前为父进程执行
  - fork之后父子进程同时执行
- 返回值  
  - 父进程返回子进程的process id
  - 子进程返回0
  
## 进程id

```c++
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);
```

- getpid()返回调用者id
- getppid()返回父进程id，如果创建该进程的父进程已经终止，则返回回收这个子进程的id

  
  
## execve()

```c++
#include <unistd.h>

extern char **environ;

int execve(const char *pathname, char *const argv[],
           char *const envp[]);
int execl(const char *pathname, const char *arg, ...
                /* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
                /* (char  *) NULL */);
int execle(const char *pathname, const char *arg, ...
           /*, (char *) NULL, char *const envp[] */);
int execv(const char *pathname, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
            char *const envp[]);
int fexecve(int fd, char *const argv[], char *const envp[]);                       
```

- 以上7个函数统称为exec函数, fork创建的子进程需要调用exec函数执行另一个程序
- 不会创建一个新进程, 进程的大多数属性并没有改变
- 新程序从其main函数开始执行, 重新初始化栈，堆，data segments
- 调用成功无返回值, 失败返回-1，并设置errno
- 参数
  - pathname必须是一个二进制**可执行文件**或**脚本文件**
  - filename：包含`/`则视为路径名, 否则在PATH[^path]环境变量所指定的各目录中搜寻可执行文件。
  - `argv[]`: 字符串，执行程序的运行参数
  - `envp[]`: 字符串，通常是key=value的形式执行程序的环境参数
- exec前后UID和GID是不变的，而有效ID取决于所执行程序文件所有者ID是否设置， 若已设置则有效用户ID变成程序所有者的ID，否则有效用户ID不变
  [[Linux文件ID]]  
  
[^path]:PATH包含了一张目录表(路径前缀)，用冒号`:`隔开, 
                    如: PATH=/bin:/usr/bin:/usr/local/bin