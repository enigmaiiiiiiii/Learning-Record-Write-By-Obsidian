# 互斥变量
  
- 初始化后，变量处于未锁状态
- 一般由主线程初始化
- 两种初始化方法
  
```c++
#include <pthread.h>  
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                       const pthread_mutexatttr_t *restrict attr);
                       // attr指定mutex的属性
int pthread_mutex_destroy(pthread_mutex_t *mutex);  // 销毁                       
```

- 变量类型
  - PTHREAD_MUTEX_NORMAL: 基本类型 
  - PTHREAD_MUTEX_RECURSIVE: 递归类型，多次加锁，相同次数解锁
  - PTHREAD_MUTEX_ERRORCHECK: 报告错误
  - PTHREAD_MUTEX_DEFAULT: 默认类型
- 互斥变量属性
   - 类似线程属性可以(设置)set和(查询)get

```c++  
#include <pthread.h>
int thread_mutexattr_init(pthread_mutexattr_t *attr);
int thread_mutexattr_destory(pthread_mutexattr_t *attr);
```

## 加锁和解锁

```c++
#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);  // 加锁, 调用线程占有
int pthread_mutex_trylock(pthread_mutex_t *mutex);  // 
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

- 如果mutex类型是PTHREAD_MUTEX_NORMAL, 重复对mutex加锁会导致死锁

## 读写锁

- 以读方式上锁，允许另外一个线程以读的方式共享数据
- 以写方式上锁, 其他线程读写受阻
- 特点
  - 保证共享数据读写一致
  - 使读操作并行执行

```c++
#include <pthread.h>
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
                        const pthread_rwlock_t *restrict attr);
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);  
// 创建读写锁属性对象
int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
int pthread_rwlockattr_destory(pthread_rwlockattr_t *attr);
// 以读的方式上锁
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
// 以写的方式上锁
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
// 解锁方式
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
```

- 读写锁创建后, 其属性可以查看，不能改变
-  默认属性是PTHREAD_PROCESS_PRIVATE, 表示只作用于一个进程内

## 条件互斥变量


```c++
#include <pthread.h>
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;  // 静态初始化
// 如果cond是用alloc创建的，只能使用pthread_cond_init初始化 
int pthread_cond_init(pthread_cond_t *restrict cond, 
                      const pthread_condattr_t *restrict attr);
int pthread_cond_destroy(pthread_cond_t *cond);

```

### 等待函数


```c++
int pthread_cond_wait(pthread_cond_t *restruct cond, 
                      pthread_mutex_t *restruct mutex);
int pthread_cond_timewait(pthread_cond_t *restrict cond, 
                          pthread_mutex_t *restrict mutex,
                          const struct timespec *restruct abstime);                      
```

- 调用之前mutex必须处于锁状态
- 未收到唤醒条件，执行过程中阻塞
- 阻塞的同时，解锁
- 完成调用后，加锁
- 等待函数是**可取消点**
  - 因为线程取消而取消阻塞的线程不会消耗唤醒变量发出的信号
  - 在等待函数处取消的副作用，线程会将互斥变量上锁 
  - 所以需要调用清理函数
   [[线程取消]]

### 唤醒条件变量

```c++
#include <pthread.h>
int pthread_cond_signal(pthread_cond_t *cond);  // 至少唤醒一个线程，
int pthread_cond_broadcast(pthread_cond_t *cond); // 唤醒所有等待条件的线程
```

- 执行这两个函数时, 可以理解为满足条件
