# Merge Sort

- 时间复杂度$O(n^2)$
-  有临时数组时, 空间复杂度$O(n)$

## 算法分析

- 变量定义
  - `merge(std::vector<int> nums, int left, int right)`, 合并函数
  - nums: 待排序数组
  - left: 分割后的左边界
  - right: 分割后的右边界
  - tmp:临时数组, 存储已排好顺序的元素, 每次递归tmp都会更新
  - mid: 分割点，左区间为$[left,mid]$, 右区间为$(mid, right]$
  - i: 左指针指向分割后的左数组 
    - `i = left;`
  - j: 右指针指向分割后的右数组
    - `j = mid + 1;`
  - cur: 指向临时数组元素的指针
- 分割合并过程
  - 找到中点`int mid = (left + right) / 2;` 
  - 递归左半部分`merge(nums, left, mid);`
  - 递归右半部分`merge(nums, mid + 1, right);`
  - 递归返回条件:  `if (left == right) return;`, 表示数组不能再被分割, 数组中只有一个元素
  -  **递归返回后**开始合并
  - 左指针`i`和右指针`j`分别从左右数组的起点开始
    - `nums[i]`和 `nums[j]` 中较小值赋值给`tmp[cur]`
    - 元素确定位置后的数组指针+1 `i++;` 或 `j++;`
  - 当一个数组指针指向末尾时, 说明当前数组元素位置已全部确定，另一数组的剩余元素均大于已排序元素
  - $[left, right]$范围的元素已排序完成
  - 返回上一递归过程