# 处理类型

## typedef关键字,定义类型别名

  ```c++
  typedef double wages;
  typedef wages base,*p;  // base是double的别名,p是double*的别名
  ```

- 复合类型或常量的类型别名

  ```mermaid
  graph TB
  A0[typedef char *pstring]-->A
  A[pstring是char*的类型别名]-->B[const pstring cstr = 0]; 
  A-->C[const char *cstr = 0];
  B--类型是const指针-->D[cstr的类型char *const];
  C--指向常量的指针,底层指针-->E[cstr的类型是const char*]
  ```

  [[const限定符#指针和const]]

  ```c++
  typedef char *pstring;  // pstring是char*的别名
  const pstring cstr = 0;  // cstr是指向char的const指针 
  const pstring *ps;  // ps是一个指针，他的对象是指向char的常量指针
  ```

- `typedef int arrT[10];`arrT是一个包含10个整型的数组

```c++
typedef int arrT[10];
using = arrT = int[10];
arrT* func(int i);  // 对func的返回值解引用得到包含10个整型的数组，因此func的返回类型是数组指针
```

- c语言中typedef可以用来定义结构体

```c
typedef struct
{
    int a;
    double b;
} structname;
```


## using别名声明

- `using wages = double;`表示wages是double的别名

## auto说明符，让编译器去分析表达式的类型

- auto会忽略掉顶层const,底层const会保留下来
- 顶层const需明确指出`const auto f = ci;`
- 若表达式是引用对象，auto以引用对象的类型作为auto的类型

```c++
int i = 0;
int &r = i;
const int ci = i;
const int &cr = ci;
auto a = r;  // r is alias of i,type is int; a is int
auto b = ci;  // b type is int
auto c = cr;  // c type is const int
auto d = &i;  // d type is int*
auto e = &ci  // e type is const int*
```

## decltype类型推导符

- 为泛型编程设计，主要解决有些类型有模板参数决定而难以表示的问题
- decltype分析**变量**类型,**表达式**计算类型,**函数**返回的数据类型，声明或定义变量类型为**相应**数据类型

```c++
decltype(func()) x = a; 
// decltype的作用是分析func函数的返回值类型，将x声明或定义为此类型
```

- decltype不会忽略顶层const和引用操作

```c++
cosnt int ci = 0, &cj = ci, *cp = ci;
decltype(ci) x = 0;  // x的类型是const int, 是顶层const
decltype(cj) y = x;  // y的类型是const int&, 底层const, 指向const的引用
```

- 对于解引用操作，**decltype**仍将得到引用类型

```c++
int i = 42, *p = &i, &r = i
decltype(r + 0) a;  // r + 0 是一个表达式, a的类型是int
decltype(r) b;  // r是一个变量，b是引用 
decltype(*p) c;  // c是一个引用
```

- decltype对于变量名**加括号**与**不加括号**得到的类型不同
  - 不加括号：得到该变量类型
  - 加括号：编译器会把它当成一个表达式，变量是可以作为赋值语句左值的特殊表达式,会得到引用类型
  - decltype((*variable*))的结果永远是引用，decltype(*variable*)的结果只有当variable本身是引用时才是引用

  ```c++
  int i = 42;
  decltype((i)) d;  // 错误：d是引用，必须初始化
  decltype(i) d;  // √
  ```