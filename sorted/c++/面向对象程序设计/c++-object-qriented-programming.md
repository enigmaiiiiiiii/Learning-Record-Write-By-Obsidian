# 面向对象程序设计

- OOP的核心思想是**多态(polymorphism)**

[virtual函数](c++-virtual-function.md)

[[成员访问控制]]

[[对象访问控制]]

[[可访问性对派生类向基类转换的限制]]

[[面向对象设计理念]]

[[继承中的作用域]]

[继承体系中的构造函数和拷贝控制](c++-constructor-and-copy-control-in-inheritance.md)

- 派生类构造函数只初始化它的直接基类

## 关系

- <font color="red">基类的指针或引用可以绑定到派生类上 </font>
- <font color="red">基类的指针或引用不能向派生类转换</font>

## 基类

- virtual成员
- static成员：整个继承体系只存在**唯一**实例,遵循访问控制
- 一个类被用作基类之前必须定义
- 类名后加`final`表示该类不能被继承
  
## 派生类
 
- `class A:public B { }`, A是B的派生类, A继承自基类B
- 包含基类的成员和派生类自定义成员
- 继承自基类的成员需用**基类**的构造函数初始化
  
## 静态类型和动态类型

- 变量或表达式的动态类型和静态类型是**共存**的
- 静态类型：变量<font color="red">声明</font>时的类型或<font color="red">表达式生成的类型</font>
  - 编译时就已确定
  - 哪些成员可访问是由**静态类型**决定的
- 动态类型：变量或表达式表示的内存中的对象类型,实际类型
  - 动态类型的变化范围不超出整个派生体系
  - 运行时调用函数才确定
  - 继承类型之间的转换，转换的是**动态类型**
- 如果表达式既不是**引用**也不是**指针**，则动态类型和静态类型一致

## 有继承关系的类型之间的转换

- <font color="red">从派生类向基类转换只针对指针或引用有效</font>
- 派生类有的成员基类不一定有，所以基类不能向派生类转换
- 从派生类向基类的转换也可能因为[访问受限](可访问性对派生类向基类转换的限制.md)的问题变得不可行
- 基类向派生类不存在隐式转换
- 对象之间不存在转换, 在赋值和拷贝期间实际上转换的是参数的隐式转换

