# 面向对象程序设计

- OOP的核心思是**多态(polymorphism)**
- 基类
  - virtual成员
  - static成员：整个继承体系只存在**唯一**实例,遵循访问控制
  - 一个类被用作基类之前必须定义
  - 类名后加`final`表示该类不能被继承
- 派生类
  - `class A:public B { }`, A是B的派生类, A继承自基类B
  - 包含基类的成员和派生类自定义成员
  - 继承自基类的成员需用**基类**的构造函数初始化
- **基类**的**指针**或**引用**可以绑定到**派生类**上
- 静态类型和动态类型
  - 变量或表达式的动态类型和静态类型是**共存**的
  - 静态类型：变量**声明**时的类型或表达式生成的类型
    - 编译时就已确定
    - 哪些成员可访问是由**静态类型**决定的
  - 动态类型：变量或表达式表示的内存中的对象类型,实际类型
    - 动态类型的变化范围不超出整个派生体系
    - 运行时调用函数才确定
    - 继承类型之间的转换，转换的是**动态类型**
  - 如果表达式既不是**引用**也不是**指针**，则动态类型和静态类型一致
- 有继承关系的类型之间的转换
  - <font color="red">从派生类向基类转换只针对指针或引用有效</font>
  - 从派生类向基类的转换也可能因为访问受限的问题变得不可行
    参考[[可访问性对派生类向基类转换的限制]]
  - 基类向派生类不存在隐式转换
- 对象之间不存在转换, 在赋值和拷贝期间实际上转换的是参数的隐式转换
- 派生类构造函数只初始化它的直接基类

[[virtual函数]]

[[成员的访问控制]]

[[对象的访问控制]]

[[可访问性对派生类向基类转换的限制]]

[[面向对象设计理念]]

[[继承中的作用域]]

