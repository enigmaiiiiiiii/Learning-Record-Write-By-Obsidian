# 对象移动

- 移动赋值运算符`Foo operator=(Foo &&rhs) noexcept`

## 右值引用

- 不能绑定到左值上
- 符号&&
- 只能绑定一个将要销毁的对象, 临时对象
- 可以绑定一个表达式: `int &&rr = i * 42;`
- 可以是字面值的引用: `int &&rr = 42;`

## move函数

- utility头文件
- 返回一个绑定到左值上的右值引用
- move后源对象除**赋值**或**销毁**外，不再使用
- move不会重新分配内存
- 移动后的源对象必须可析构

## 移动构造函数

- 第一个参数是该类类型的一个**右值引用**
- `Foo(Foo&&) noexcept {}`
- 不分配任何新内存
- 移动后的源对象要保证销毁它是无害的
- 合成移动构造函数
  - 永远不会隐式定义为删除函数
  - 显示=default在编译器不能移动所有成员会定义为删除函数
  - 编译器不会为某些类合成移动操作
    - 比如一个类定义了自己的拷贝构造函数，拷贝赋值运算符，或者析构函数
  - 不是必须的，没有也可以,类会使用拷贝操作来代替移动操作
  - 编译器合成移动构造函数的必要条件
    - 当一个类没有定义任何自己的拷贝控制成员 
    - 所有数据成员都能**移动构造**或**移动赋值**时

## 关键字noexcept

- **noexcept**是代码不抛出异常的一种**承诺**
- **noexcept**出现在一个函数的参数列表后,初始化列表开始的冒号之前
- 必须在类头文件的声明中和定义中都指定noexcept
- <font color="red">理解标准库与自定义类型中noexcept之间的联系</font>
  - 标准库在程序员移动类对象时认为可能会抛出异常
  - 移动操作不抛出异常，但是抛出异常是允许的
  - 标准库**容器**能在异常发生时提供保障，如vector容器push_back异常，vector自身不会改变
    [[顺序容器]]
  - 在移动过程中抛出异常
    - 可能导致旧元素以改变，新元素未构造的情况
    - 为了避免这种问题，vector除非知道在使用移动构造函数过程中不会抛出异常，  
      否则在重新分配内存过程中, 他就使用**[[拷贝构造函数]]**而不是**移动构造函数**
    - 容器，如vector，在重新分配内存过程中，
      需要对对象元素进行移动而不是拷贝就必须显式告诉标准库: 
      自定义的移动构造函数可以安全使用, 通过noexcept来实现这一点