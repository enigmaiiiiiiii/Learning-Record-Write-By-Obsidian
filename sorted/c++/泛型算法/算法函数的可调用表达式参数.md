#  算法函数的可调用表达式参数

## lambda表达式

- 表示一个可调用的代码单元
- 可以向算法函数传递任何类别的**可调用对象**
- lamdba表达式形式:
- 适合使用次数不多，临时使用
- 表达式样式`[capture list](parameter list) -> return type {function body}`
- capture list: 捕获局部变量列表，可为空，且通常为空
  - 值捕获:`[var](){}`; 隐式值捕获:`[=](){}`
  - 引用捕获：`[&var](){}`; 隐式引用捕获:`[&](){}`
  - 隐式捕获
    - 让编译器判断要使用的变量
    - `[=]`,引用隐式捕获
    - `[&]`,值引用捕获
    - 隐式显式混合使用时，第一个元素必须表示隐式捕获类型，且显式捕获类型不能和隐式相同
  - 尽量减少捕获数据量
  - 对于值捕获，参数列表后加mutable，可改变捕获列表变量值
- `parameter list`: 参数列表, 可为空
- `-> return type`: 返回类型, 可为空
  - 如果function body包含return之外的语句，则编译器默认返回void,编译器推断不出返回类型
- function body：函数体
- 必须使用尾置返回类型来指定返回类型
  [[返回类型#尾置返回类型]]
- 参数传递:不能有默认参数

```c++
auto f = [] () {return 42;}; 
```

## 标准库bind函数

- 作用：
  - 适应可调用对象接受的谓词数量，接受一个可调用对象(*callable*)，生成一个新可调用对象(*callable*)
  - 重排参数顺序
- 一般形式:`auto newCallable = bind(callable, arg_list);`
- arg_list对应callable函数的参数
- _num参数用来表示 *newCallable* 的第num个参数
  - _num占位参数定义在一个placeholders命名空间，placeholders本身命名在std命名空间
  - _num参数可以用来定义 *newCallable* 的参数顺序
- 参数的传递方式是拷贝
- 对于不能拷贝的对象，需要使用标准库函数ref

  ```c++
  bind(print, ref(os), _1, ' ');
  ```

```c++
auto check6 = bind(check_size, _1, 6);  // 用check_size定义了一个新函数check6, check6只接受一个参数
```