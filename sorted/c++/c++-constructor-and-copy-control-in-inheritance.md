# 派生体系中的构造函数与拷贝控制

## 虚析构函数

- 基类通常应该定义一个虚析构函数
- 如果不是, 使用基类指针调用派生类对象后, 再释放基类对象派生类的析构函数得不到执行

 > 虚析构函数有虚函数的特性，动态绑定情况下，删除一个指向派生类对象的基类指针会发生未定义行为

## 派生类构造函数

- 派生类不能直接初始化继承自基类的成员
- 派生类使用基类的构造函数初始化基类的部分
- 派生类通过[初始化列表](c++-class-constructor.md)将实参传递给基类

```c++
// 由编译器生成的构造函数
derived(parms) : base(args) {}
```

parms是构造函数形参列表
args是parm中传递给基类构造函数的实参

- 对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数
- 基类构造函数有默认实参时，派生类获得多个构造函数
 - 将实参换成形参
 - 省略实参参数
- 派生类可以定义有相同参数列表的构造函数，覆盖基类中对应的构造函数


## 合成拷贝控制

- [如果一个类需要析构函数，那么他同样需要拷贝和赋值操作](c++-三五法则.md)
- 合成成员对类本身的成员依次进行初始化, 赋值和销毁

合成删除

 - 如果基类中的默认构造函数，拷贝构造函数，拷贝赋值运算符或析构函数是被删除的或不可访问, 则派生类中的对应成员也是被删除的

合成移动

## 派生体系中构造，拷贝，析构

- 构造, 拷贝和赋值运算符需要考虑初始化基类部分或为基类成员赋值
- 析构函数只负责销毁派生类自己分配的资源

> 与构造顺序相反 

## 调用虚函数的对应版本

- 构建派生类对象的过程类似动态绑定过程

## 是否可继承

- 派生类不能继承默认，拷贝和移动构造函数
- 如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数
- 派生类继承基类的构造函数通过一条[using]语句

> using用来说明某个名字当前作用域可见

```c++

class Bulk_quote: public Disc_quote 
{
public:
    using Disc_quote::Disc_quote; // 继承基类构造函数
    double net_price(std::size_t) const;
}

```