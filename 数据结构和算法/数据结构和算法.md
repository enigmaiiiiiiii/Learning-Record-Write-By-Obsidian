# 数据结构和算法



## 数组

- 数组在内存中是连续的

### 特殊情况特别关注

- 数组维度(size)为0

## 链表

- 链表在内存中不是连续分布的, 地址取决于操作系统
- 链表的表头是唯一确定的
- 单向链表定义
  - 元素
  - 指针指向下一节点
  - 构造函数
- 首元素节点：存储第一个元素的节点
- 头指针：指向第一个节点的指针
- 为了方便处理会设一个头节点
  - 头节点：指向首节点的节点
  - 便于处理首元素节点

```c++
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```

- 链表删除
- 添加节点

## 哈希表

- 哈希音译自英语hash，hash表示散列
- 使用哈希函数将键映射到存储桶
  - 插入新键:哈希函数决定该键分配到哪个桶
  - 搜索键：使用哈希函数映射到对应的桶，并只在对应的桶中进行搜索
- 哈希函数`hashFunction(key)`, 返回值是哈希地址
- 哈希函数的选取
  - 直接定址：
  - 数字分析：
  - 除余法：`hash(key) = key % P + b`, 理论和实践表明 p 应选取小于存储容量的素数
  - 平方取中法：k为键，取k2</sup>的中间几位作为哈希地址, 位数可根据表长决定，如1000，可取中间三位数
  - 折叠法：
  - 哈希函数的选取是一个开放问题
- 冲突：不同的键映射到相同的哈希地址
- 决定查找效率的因素
  - 哈希函数是否均匀
  - 冲突解决方法
  - 元素个数与哈希表长度

### 解决冲突

- 1. 线性探测: i为键映射的地址，发生冲突时检测$i+1$是否为空，否则检测$i+2$，依次递增
- 2. 二次探测: 增量为$1^2, -1^2, 2^2, 2^2$
- 3. 再哈希:若哈希函数`H1(key)`发生冲突，则用`H2(key)`生成一个新地址,依次`H3(key)`,`H4(key)`,直到产生不冲突地址
- 4. 链地址法：将哈希地址作为一个指针，指向一个**链表**,若哈希表长度为m，则建立m个空链表
- 5. 建立溢出区

## 栈

- 出题类型
  - 括号匹配
  - 删除相邻重复单词
  - 逆波兰表达式

## 树

- 树
  - 根节点没有前驱元素
  - n个数据元素被分为m个互不相交的集合，集合本身又是一个树
- 相关概念
  - 结点的度：结点的分支数
  - 终端结点(叶子节点)：度为0的结点
  - 非终端结点: 度不为0的结点
  - 树的度：树中所有结点度的最大值
  - 树的深度：树中所有结点层次的最大值
  - 有序树、无序树：如果树中每棵子树从左向右的排列拥有一定的顺序，则成为有序树，否则称为无序树
  - 森林:m棵互不相交的树的集合


## 二叉树

- **满二叉树**：如果一个深度为K的二叉树拥有$2^K-1$个结点，则称为满二叉树
  - 一个单独结点是一个满二叉树
- **完全二叉树**：有一颗深度为$h$，具有$n$个结点的二叉树，  
若将一颗与它同深度的满二叉树中的所有结点按**从上到下**、**从左到右**的顺序分别进行编号,  
且该二叉树中的每个节点分别于满二叉树中编号为1~n的结点位置一一对应，则称这棵二叉树为完全二叉树
- **平衡二叉搜索树**：左右两个子树的高度差绝对值不超过1，并且左右两个子树都是一颗平衡二叉树
  - c++中map,set,multimap,multiset的底层实现都是平衡二叉树
- **二叉搜索树**: 有数值，有序的树  
  - 左子树小  
    > 若左子树不空，则左子树上所有结点的值均**小于**它的根节点的值
  - 右子树大  
    > 若右子树不空, 则右子树上所有结点的值军**大于**它的根节点的值
  - 左右子树也分别为二叉搜索树

### 二叉树的性质

- 性质1：二叉树的第i层上最多有$2i-1$个结点
- 性质2：深度为K的二叉树最多有$2_K-1$个结点
- 性质3:对于任意一颗二叉树BT,如果度为0的结点个数为$n_0$,度为2的结点个数为$n_2$,则$n_0 = n_2+ 1$
- 性质4: 具有n个结点的完全二叉树的深度为$(log_2n)+1$,其中$log_2n$的结果是不大于$log_2n$的最大**整数**
- 性质5: 对于有$n$个结点的完全二叉树中的所有结点按从上到下、从左到右的顺序进行编号，则对任意一个结点$i$,都有
  - 如果$i = 1$,则结点$i$是这棵完全二叉树的根，没有双亲；否则，其双亲结点的编号为$i/2$
  - 如果$2i>n$,则结点没有左子嗣，否则左子结点的编号为$2i$
  - 如果$2i+1>n$,则结点没有右子嗣，否则，其右子结点的编号为$2i+1$
  - 应用：对于顺序存储结构，如结点在数组中的下标为i，  
    其左子结点的元素下标为$2i$(如果存在)，  
    右子节点的下标为$2i+1$,  
    父节点为$i/2$

性质3推导:
$$
\left\{
\begin{aligned}
& n = n_0 + n_1 + n_2 \\
& B = n_1 + 2n_2 \\
& n = B + 1 \\
\end{aligned}
\qquad \right. \Rightarrow n_0 = n_2 + 1  \\

B: 二叉树的分支总数 \\
n_0:0度结点个数  \\
n_1:1度结点个数  \\
n_2:2度结点个数  \\
$$

### 二叉树的存储

- 顺序存储结构
  - 用一组连续存储单元按照完全二叉树的每个结点编号的顺序存放结点内容
  - 可以体现结点间的关系
  - 不适合非完全二叉树
- 链式存储结构
  - Leftchild $\longleftarrow$ data $\longrightarrow$ Rightchild

### 遍历二叉树

- 遍历是一个**递归**过程
- 通常从左往右遍历
- TLR(中左右): 先序遍历
- LTR(左中右): 中序遍历
- LRT(左右中): 后序遍历

  ```c++
  if (root == nullptr) return;
  std==cout<< root->val << std==endl;  // 前序遍历
  recusion(root->left);
  std==cout<< root->val << std==endl;  // 中序遍历
  recusion(root->right);
  std==cout<< root->val << std==endl;  // 后序遍历

  ```

## 堆

- 可以看作一种二叉树
- 大顶堆: 每个节点的值都**大于**或等于器左右子节点
- 小顶堆: 每个节点的值都**小于**或等于器左右子节点

## 算法

### <span id="recursion">递归</span>

- 设计方法
  - 递归出口,也可以说结束条件
  - 接近结束条件:每次递归都接近结束条件
  - 寻找子问题
- 理解递归
  - <font color="red">既然递归每一级都是一样的，因此只关注一级递归做了什么, 而不是去搞清楚每一层做了什么</font>
  - <font color="red">一次递归即终止</font>
  - <font color="red">或者说只关注最后一次递归发生了什么</font>

### 双指针

- 用于**有序**数组双元素遍历
- 一个指针遍历,一个指针操作
- 关键在于操作指针合适移动

#### 利用快慢指针删除字符串中的空格

- 快指针扫描，慢指针录入符合条件的**字符**
- 慢指针录入条件,同时满足以下三个条件
  - `fast > 1;`
  - `s[fast - 1] == s[fast];`
  - `s[fast] == ' ';`
- 最终结果为begin到**慢指针所指字符**
- 通过resize成员函数进行裁剪

### KMP算法(模式匹配算法)

> 以三位发明者名字的首字母

- 用模式字符串生成前缀表(next数组)
  - **初始化**后缀下标i，前缀下标j
  - 考虑前后缀**不同**的情况`while (j > -1 && s[i] != s[j + 1]) {j = next[j]}`
  - 考虑前后缀**相同**的情况`if (s[i] == s[j + 1]) {j++}`
  - 给next元素赋值`next[i] = j;`
- 使用前缀表匹配
  - 文本串`s[i]`, 模式串`t[j]`
  - 遍历文本串`for (int i = 0;i < s.size(); i++)`
  - 文本串与模式串不匹配: `while (j >= 0 && s[i] != t[j]) j = next[j];`
  - 文本串与字符串匹配:`if (s[i] == t[j]) j++;`
- 主要应用于字符串匹配
- KMP不会回溯原始字符串，所以速度较快

#### 关于前缀表next数组

- next数组
  - size等于模式串的长度
  - 元素: 分别得到所有包含首字符的子串,前缀与后缀最长相同长度
  - 前后缀不同j回溯
  - 前后缀相同`j++`
  - j有两个含义
    - next元素
    - 返回位置的下标

  ```c++
  void getNext(int* next, const string& s) {
    // j有两个含义：①下标，②next数组元素
    int j = -1;
    next[0] = j;
    for(int i = 1; i < s.size(); i++) { // 注意i从1开始
      while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不同, 回退
        j = next[j]; // 向前回溯
      }
      if (s[i] == s[j + 1]) { // 找到相同的前后缀
        j++;
      }
      next[i] = j; // 将j（前缀的长度）赋给next[i]
    }
  }
  ```

## 时间复杂度分析

- 用$O(f(n))$来表示时间复杂度
- 假设$T(n)$是数据规模为$n$时所消耗的时间，  
如果存在整的常数$C$和$n_0$,使得当$n \geq n_0$时都满足$0 \leq T(n) \leq C*f(n)$,  
则称$T(n)$与$f(n)$同数量级，并记作$T(n) = O(f(n))$为该算法的时间复杂度。

> $T(n) = 2n^3 + 3n^2 + 2n + 1$  
  当$n \rightarrow \infty$时：  
  $T(n) / n^3 = (2n^3 + 3n^2 + 2n + 1) / n^3 \rightarrow 2$  
  所以时间复杂度时$O(n^3)$

- 常见的时间复杂度
  - $O(1)$ 
  - $O(log_2n)$
  - $O(n)$
  - $O(n^2)$
  - $O(n^3)$

- 分析方法
  - 选取一种基本操作分析, 该操作的次数
- 通常以最坏的时间复杂度作为算法的复杂度