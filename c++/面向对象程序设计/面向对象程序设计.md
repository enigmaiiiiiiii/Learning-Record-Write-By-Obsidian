# 面向对象程序设计

- OOP的核心思是**多态(polymorphism)**
- 基类
  - virtual成员
  - static成员：整个继承体系只存在**唯一**实例,遵循访问控制
  - 一个类被用作基类之前必须定义
  - 类名后加`final`表示该类不能被继承
- 派生类
  - `class A:public B { }`, A是B的派生类, A继承自基类B
  - 包含基类的成员和派生类自定义成员
  - 继承自基类的成员需用**基类**的构造函数初始化
- **基类**的**指针**或**引用**可以绑定到**派生类**上
- 静态类型和动态类型
  - 变量或表达式的动态类型和静态类型是**共存**的
  - 静态类型：变量**声明**时的类型或表达式生成的类型
    - 编译时就已确定
    - 哪些成员可访问是由**静态类型**决定的
  - 动态类型：变量或表达式表示的内存中的对象类型,实际类型
    - 动态类型的变化范围不超出整个派生体系
    - 运行时调用函数才确定
    - 继承类型之间的转换，转换的是**动态类型**
  - 如果表达式既不是**引用**也不是**指针**，则动态类型和静态类型一致
- 有继承关系的类型之间的转换
  - <font color="red">从派生类向基类转换只针对指针或引用有效</font>
  - 从派生类向基类的转换也可能因为[**访问受限**](#translimit)的问题变得不可行
  - 基类向派生类不存在隐式转换
- 对象之间不存在转换, 在赋值和拷贝期间实际上转换的是参数的隐式转换
- 派生类构造函数只初始化它的直接基类

## <span id ="virtualfunc">virtual函数</span>

- 是**基类**希望**派生类**覆盖的函数
- 运行时根据**指针**或**引用**所绑定对象的实际类型来选择执行虚函数的某一个版本,也叫**动态绑定**
- 使用**指针**或**引用**调用虚函数时，该调用将被动态绑定
- 通过**指针**或**引用**对虚函数的调用直到运行时才被解析
- 出现在类内部声明语句之前
- 不能出现在类外部定义
- 必须有定义; 区别于普通函数的可以只声明不定义
- 派生类的虚函数的返回类型必须与基类一致或满足继承关系的转换
- 如果派生类的虚函数覆盖了某个继承而来的虚函数，则[它的形参必须与被覆盖的基类虚函数一致](#virtualfuncargs)
- 一旦函数被声明成虚函数，则在所有派生类中都是虚函数
- `override`关键字
  > 在派生类中，定义与基类虚函数同名，参数列表不同的函数是允许的;  
  但不推荐，因为不方便调试发现错误，所以新标准添加了override关键字
  - 用在**派生类**中
  - **基类同名虚函数参数列表**以及**尾置返回类型**之后
  - 表示该函数需与原函数参数列表需完全一致, 否则编译器报错
- `final`表示改函数不能被覆盖
  - 用在形参列表及尾置返回类型之后
  - 表示该函数不能被覆盖
- 通过`int i = B->A::func()`来强制调用基类A中的成员func,即使func在派生类B中重新实现过
- 纯虚函数
  - 可以不定义，并在不定义的状态下被派生类覆盖
  - 在函数体处填写`=0`,用来表示这是一个纯虚函数,表示该函数无定义,若要提供定义须在类外部定义
  - 含有纯虚函数的类被称为抽象基类
    - 定义接口供派生类实现
    - 不能创建抽象基类的对象
  - 专门用来继承，避免编写无意义代码

## 成员的访问控制

- 外观：`public int func(args) {}`
- `private` **友元**和**基类**可以访问, **派生类**不可以访问
- `protected` **基类**，**派生类**和**友元**可以访问
  - 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员
- using声明可以改变**基类成员**的访问权限，**派生类**中**被using改变的成员**的访问权限由using之前的访问控制符决定

## 对象的访问控制

- 外观: `class Pub_Derv : public Base {}`
- **派生类的访问说明符**对**派生类的成员和友元**能否访问其直接基类的成员没什么影响
- **派生类的访问说明符**控制的是 <font color="red">**派生类的对象(实例)**</font> 对基类成员的访问权限
- **派生类的访问说明符**还会继续控制派生类的**下游**派生类
- `public`
- `private` 表示基类中的public成员对于**派生类的对象**都是private
- `protected` 表示基类中的public成员对于**派生类和友元对象**都是protected

## <span id="translimit">可访问性对派生类向基类转换的限制</span>

- 派生类只有public继承，<font color="red">**使用类的代码**</font>才能使用派生类向基类的转换
- 派生类无论以什么方式继承, <font color="red">**派生类**</font>的成员函数和友元都能使用派生类向基类的转换
- 派生类以public或protect的方式继承基类时，<font color="red">**派生类的派生类**</font>成员和友元可以使用派生类向基类的转换

## 面向对象设计理念

- **普通用户**编写代码来使用类的对象
- **类设计者**负责编写类的成员和友元
- 基类希望派生类能够使用的部分声明成protected的，普通用户不能访问
- 基类的private成员，**派生类**以及**派生类的友元**也不能访问
- 基类的接口应该声明成public
- 基类应该将**由其本身实现的部分**分为两种
  - 可供派生类访问,声明成protected
  - 只能由基类以及基类的友元访问,声明成private
- 用struct定义public继承，用class定义private继承;只是一种增加可读性的约定，两者没有任何不同之处

## 继承中的作用域

- 派生类的作用域嵌套在其基类的作用域之内
  - 通过引用或指针调用成员时,  
  一个名字在派生类作用域内无法解析，则编译器将继续在**外层**的基类作用域中寻找该名字的定义
  > 由内而外的搜寻

- 内层作用域的名字**隐藏**外层作用域的名字
  > 隐藏的意思是在调用派生类成员函数时，  
  内层只有名字相同而参数不同的成员，而即使外层有相同的成员时,  
  编译器找不到外层对应成员函数而报错
- <span id="virtualfuncargs">假如基类和派生类的虚函数接受的实参不同，则无法通过基类的引用或指针调用派生类的虚函数</span>
  - [参数不同则函数的类型不同](#functype)

---

# <span id="template"><font color="gold">模板</font></span>

- 以template加模板参数列表`<template T>`开头
- 函数模板
  - `template <typename T> int compare(const T &v1, const T &v2) {}`
  - 调用模板函数时，编译器通过实参类型推断T的类型
  - 类型参数前使用关键字classname或typename
  - 非类型参数, 用来传递一个值，值必须是[常量表达式]
- 编写泛型代码的两个重要原则
  - 模板中的参数是const的引用
    - 为了保证函数可以用于不能拷贝的类型
  - 函数体中的条件判断仅使用<比较运算
    - 降低可函数对处理类型的要求，这些类型必须支持`<`,而不必支持`>`
- 类模板
  - `template <typename T> class Blob {}`
  - 类的成员函数也是一个模板, 必须以`template <template T>`开头

## 模板特例化