
# 顺序容器

- 包括**vector(向量), deque(双端队列), list(链表), forward_list(单向链表), array(数组), string(字符串)**
- 除array外，标准库容器都可以改变大小
- 容器选择原则
  - 要求随机访问容器元素应使用vector或deque
  - 在头尾插入或删除，而不会在中间位置进行插入或删除，则使用deque

## [[容器操作]]

- 某些操作是所有容器都提供的
- 一些操作针对**顺序容器**，有的仅针对**关联容器**，有的针对**无序容器**
- 还有一些只适用于小部分容器
- 迭代器范围首元素到尾后元素, **[begin, end)**
  - begin等于end时，范围为空  
  - begin与end不相等，则范围至少包含一个元素，begin指向第一个元素
  - 我们可以对begin递增若干次,使begin == end为true
- cbegin和cend是容器的const成员，**返回类型**为const_iterator，属于底层**const**
- cbegin和cend可以**读**，不可以**写**
- c++过去必须**显示**声明用那种迭代器; 新标准实现用**auto**声明迭代器

  ```mermaid
  graph LR
  A[普通iterator] --可以转化--> B[const_iterator]
  B --不能转化--> A
  ```

  ```c++
  while (begin != end) {
      *begin = val;
      ++begin;
  }
  ```

## 容器类型成员

[[容器操作]]

- 常见的由size_type, iterator, const_iterator
- 为了使用这些类型，必须显示使用其类名
- 类型别名:在不了解元素类型的情况下使用
  - 广泛应用于泛型编程
  - 是容器的成员，使用作用域运算符`::`, 通过容器定义

    ```c++
    list<string>::iterator iter;  // 通过容器list<string>定义一个迭代器类型，iter是一个指向string的迭代器类型
    vector<int>::difference_type count;  // 通过容器vector<int>定义一个difference_type类型
    ```

## 容器定义和初始化

- 默认构造函数
  - `container c;`
- 拷贝初始化, c1和c2必须**容器**相同，**容器中元素**相同
  - `container c1(c2);`
  - `container c1 = c2;`
- 列表初始化
  - `container c{a,b,c...};`
  - `container c = {a, b, c...};`
- 范围初始化，迭代器初始化
  - `container c(b,e);`, **b,e**为**迭代器**, 范围为[b,e),要求**元素相容**，**不要求容器类型相同**
- 仅限于顺序容器的初始化
  - `container seq(n);`, seq包含n个元素，元素进行值初始化。
  - `container seq(n,t);`, seq包含n个初始值为t的元素
- 除数组(array)外, 其他容器的默认构造函数都会常见一个指定类型的**空容器**

## 赋值和swap

- `c1 = c2;`, 将c1中的元素替换为c2中**元素的拷贝**，c1和c2必须具有相同的类型
- `c = {a, b, c};`, 将c中元素替换为列表中元素的拷贝(array不适用), 区别于列表初始化，容器名前没有类型名
- `swap(c1, c2);`, **交换**c1和c2中的元素，c1和c2必须具有相同的类型, 同`c1.swap(c2);`,比从c2向ci拷贝快的多
- assign容器成员函数
  - 仅适用于**顺序容器(除array)**，不适用于关联容器和array
  - 允许从一个不同但相容的类型赋值
  - 传递给assign的参数不能指向调用assign的容器
  - `seq.assign(b, e);`, 将seq中元素替换为迭代器b和e所示的范围中的元素，b和e不能指向seq中的元素
  - `seq.assign(il);`, 将seq中元素替换为初始化列表il中的元素
  - `seq.assign(n, t);`, 将seq中元素替换为n个值为t的元素
- swap交换
  - `swap(c1, c2);`
  - 不交换元素，交换容器内部数据结构,除了数组
  - swap两个**数组(array)** 会交换元素,迭代器，指针，引用所绑定的**元素值**会**改变**
  - 因此swap可以在很短时间内完成
  - **除string外**，指向容器的迭代器，引用，指针都**不会失效**,且指向**swap之前**的元素
  - 对string调用swap，会导致迭代器，引用，指针**失效**
  - 新标准库中既有成员函数版本的swap, `swap(a, b);`
  - 非成员版本的swap，`a.swap(b);`
  
## 关系运算符

- ==, !=, &lt;, &gt;, &lt;=, &gt;=
- 比较两个容器实际上是对**元素 逐个**比较
- [运算法则与string类似](#strrelateoperator)
  [[string]]

### 顺序容器操作

- [添加元素](#seqcontaineradd)
  - push参数为**元素类型的对象**，将对象拷贝到容器中
  > `container.push_back(obj(a,b,c));`
  - emplace添加元素的参数与所添加类型的构造函数的参数相匹配，在容器管理内存中直接创建对象
  > `container.emplace_back(a, b, c);`
  - 添加元素添加的是对象值的拷贝
- [访问元素](#seqcontainerindex)
  - 所有方法方返回引用

  ```c++
  if (!container.empty()) {
      container.front() = 42;
      auto &v = container.back();  // v是指向container中后一个元素的引用
      v = 1024;  // c中元素会被改变
      auto v2 = container.back();  // v2是container.back()的一个拷贝
      v2 = 0;  // 未改变container中元素
  }
  ```
  
- [删除元素](#seqcontainerdel)
- [forward_list](#seqcontainerdel)(单向链表)的插入和删除元素
- 改变容器大小resize
  - `container.resize()`
  - array不支持resize
  - 大于容器原size，新增的部分由等于元素值参数的新元素或默认初始化新元素填充
- 可能导致迭代器失效的操作
  - vector或string
    - 存储空间被重新分配
    - 未重新分配空间,插入位置**之后**的迭代器，指针，引用会失效
    - 指向**被删除元素之前**的迭代器，引用，指针仍然有效
  - deque
    - 插入到**首尾元素之外**的任何位置都会导致**失效**
    - 在首尾位置添加元素，**迭代器**会失效，但指向**存在**元素的**指针和引用**不会失效
    - **首尾之外**的任何位置删除元素，指向其他元素的迭代器，引用，指针也会失效
    - 删除的是**尾元素**,**尾后迭代器**会失效，其他迭代器，引用，指针不会失效
    - 删除的是**首元素**，迭代器，引用，指针不会受影响
  - forward_list和list
    - **指向容器**的迭代器，指针，引用仍有效
    - 指向**其他位置**的迭代器，引用，指针仍有效

### vector对象是如何增长的

- 没有足够空间容纳新元素时,会将旧元素[移动](#objmove)到更大的空间，然后添加新元素
- 成员函数`size()`返回当前含有多少元素
- 成员函数`capacity()`返回容器在不分配新内存空间的前提下能保存多少元素
- 成员函数`reserve()`分配至少能容纳n个元素的内存空间
- vector在需要分配新空间时，将当前容量翻倍
- 成员函数`shrink_to_fit()`来要求vector将超出当前大小的多余内存退回系统
  > shrink_to_fit只是一个请求,标准库并不保证退还内存

### [容器适配器](stackqueue.md)

- 标准库定义了三个顺序容器适配器:stack, queue, priority_queue
- 初始化
  - 默认初始化创建一个空对象
  - 拷贝初始化, 接受一个容器
- stack和queue默认是用deque实现的
- 通过传入第二个参数，可实现底层容器类型重载`stack<int vector<int>> st`
- 适配器要求底层容器具有添加和删除元素的能力
  - 因此不能为array, 也不能为forward_list

#### stack

- `push(item)`创建一个新元素压入栈顶，该元素通过拷贝或移动item对象而来
- `emplace()`有args构造
- `pop()`删除栈顶元素，但不返回该元素的值
- `top()`返回栈顶元素
- 默认基于deque，也可以基于list或vector

#### queue

- `pop()` 返回queue的首元素或priority_queue的最高优先级元素
- `front()`返回首元素
- `back()`返回尾元素
- `top()`priority_queue中返回最高优先级元素
- `push(item)`在queue末尾或priority_queue中恰当的位置创建一个元素
- `emplace(args)`用参数构造
- 默认基于deque，也可用list或vector

#### priority_queue

- 新加入的元素会排在所有优先级比它低的已有元素之前