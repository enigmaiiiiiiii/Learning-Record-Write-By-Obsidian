
# C++中的拷贝

- 函数声明：
  - 默认构造函数`Foo();`
  - 拷贝构造函数`Foo(const Foo&) {}`
  - 移动构造函数`Foo(Foo&&) {}`
  - 拷贝赋值运算符`Foo& operator= (const Foo&) {}`
  - 移动赋值运算符`Foo operator=(Foo &&rhs) noexcept`
  - 析构函数`~Foo() {}`

```c++
string dots(10, '.');  // 直接初始化
string s(dots);   // 直接初始化
string s2 = dots;  // 拷贝初始化 
```

## 拷贝构造函数

- 用来执行拷贝初始化, 如`string s1 = s2;`
- 拷贝构造函数的参数必须是引用类型
  - 因为**非引用类型参数**形参变实参的过程就是**调用拷贝构造函数的过程**
- 会有拷贝初始化发生的情况
  - 将一个对象作为实参传递给非引用类型的形参
  - 从一个返回类型为非引用类型的函数返回一个对象
  - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

## 拷贝赋值运算符

- 重载运算符的一种，本质上是个函数, 函数返回类型`Sales_data&`
- 用来完成赋值操作`s1 = s2;`
- 返回左侧运算对象的引用`return *this`
- 标准库通常要求保存在容器中的类型具有赋值运算符
- 合成拷贝运算符会将右侧运算对象的每个非static成员赋予左侧对象的对应成员
- 拷贝赋值运算符在特定情况下可能被定义为delete

## 析构函数

- 释放对象使用的资源
- 没由返回值, 也不接受参数, 因此也不能被重载
- 自动调用析构函数
  - 变量离开作用域
  - 对象被销毁时，其成员被销毁
  - 容器(无论标准库容器还是数组), 其元素被销毁
  - 对于动态分配对象，当对指向它的指针应用delete运算符时被销毁
  - 临时对象，当创建它的表达式结束时被销毁
- 通过[直接管理内存](#newobj)创建的对象需要析构函数重点关注

## 三/五法则

- 需要析构函数的类也需要拷贝和赋值操作
- 需要拷贝操作的类也需要赋值操作，反之亦然

```c++
class HasPtr { /// 一个含有指针成员的类
public:
    HasPtr(const std==string& s = std==string()) : ps(new std::string(s)), i(0) {}
    /// 没有定义拷贝构造函数将合成拷贝构造函数
private:
    std::string* ps;
    int i;
};
HasPtr f(HasPtr hp)
{
    HasPtr ret = hp;  /// 拷贝hp
    return ret;  /// ret和hp被销毁
    /// 将导致指针成员被销毁两次
}
```

## 显式=default

合成函数隐式声明为内联,如果不希望为[内联](#inline)使用=default

## 阻止拷贝

- delete函数是这样一种函数：虽然声明了他们，但我们不能以任何方式使用。  
在函数的**参数列表**后面加上**=delete**来指出我们希望定义为删除的函数
- 例如**iostream**类阻止拷贝
- 通过将 **拷贝构造函数** 和 **拷贝赋值运算符** 定义为**delete**的函数来阻止拷贝  
- 析构函数被定义为delete，则该成员无法被销毁
- 对于某些类编译器合成的默认构造函数定义为 **delete**
  - <u>类的某个成员</u>的 ***析构函数*** 是删除的或不可访问的(如private)
  - <u>类的某个成员</u>的 ***拷贝构造函数*** 是删除或不可访问的
  - <u>类的某个成员</u>的 ***拷贝赋值运算符*** 是删除或不可访问的
  - <u>类有一个引用成员</u>没有类内初始化器，或一个const成员，没有类内初始化器且其类型未显式定义默认构造函数
  > 总结：如果一个类有数据成员不能默认构造、拷贝、复制、销毁，则对应的成员函数将被定义为删除
- private拷贝控制
  - 声明并定义private拷贝构造函数,友元和成员函数可以访问
  - 声明但不定义private拷贝构造函数,阻止任何拷贝动作，会导致编译错误和连接错误。

## 类的行为像值

- 副本与元对象相互独立
- **拷贝构造函数**要拷贝指针成员指向的对象而不是指针本身
- **拷贝赋值运算符**释放当前的指针成员所指对象，并拷贝右侧指针所指对象
- 关于赋值运算符
  - 如果将一个对象赋予自身，赋值运算符必须能够正确工作
  - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作
  - 建议模式:

  ```mermaid
  graph TD
  A[将右侧运算对象拷贝到一个局部临时对象中] --> B[销毁左侧运算对象的现有成员]
  B --> C[将数据从临时对象拷贝到左侧运算对象中]
  ```

## 类的行为像指针

- 使用的底层数据相同，改变副本会改变原对象
- 可以使用shared_ptr来实现
- 也可以进行直接资源管理，使用**引用计数**
- 使用**引用计数**
  - **创建**一个对象时，计数器初始化为1
  - **拷贝对象**共享计数器，拷贝构造函数共享递增计数器
  - **析构函数**递减计数器,计数器为0时，析构函数释放状态
  - **拷贝赋值**递增右侧运算对象计数器，递减左侧运算对象计数器
  - 一种解决方法是将计数器保存在[动态内存](#dynamicram)中

## 动态内存管理

- [code](./Code-Snippet-With-Annotation.md/#动态内存管理)
- 有些类需要自己进行内存分配，就需要定义自己的拷贝管理
- 比如在构造函数中使用了allocate类来进行内存分配和数据保存

## <span id="objmove">6. 对象移动</span>

- 右值引用
  - 不能绑定到左值上
  - 符号&&
  - 只能绑定一个将要销毁的对象, 临时对象
  - 可以绑定一个表达式: `int &&rr = i * 42;`
  - 可以是字面值的引用: `int &&rr = 42;`
- 移动赋值运算符`Foo operator=(Foo &&rhs) noexcept`
- move函数
  - utility头文件
  - 返回一个绑定到左值上的右值引用
  - move后源对象除**赋值**或**销毁**外，不再使用
  - move不会重新分配内存
- 移动后的源对象必须可析构

### 移动构造函数

- 第一个参数是该类类型的一个**右值引用**
- `Foo(Foo&&) noexcept {}`
- 不分配任何新内存
- 移动后的源对象要保证销毁它是无害的
- 合成移动构造函数
  - 永远不会隐式定义为删除函数
  - 显示=default在编译器不能移动所有成员会定义为删除函数
  - 编译器不会为某些类合成移动操作
    - 比如一个类定义了自己的拷贝构造函数，拷贝赋值运算符，或者析构函数
  - 不是必须的，没有也可以,类会使用拷贝操作来代替移动操作
  - 编译器合成移动构造函数的必要条件
    - 当一个类没有定义任何自己的拷贝控制成员 
    - 所有数据成员都能**移动构造**或**移动赋值**时

### 关键字noexcept

- **noexcept**是代码不抛出异常的一种**承诺**
- **noexcept**出现在一个函数的参数列表后,初始化列表开始的冒号
- 必须在类头文件的声明中和定义中都指定noexcept
- <font color="red">理解标准库与自定义类型中noexcept之间的联系</font>
  - 标准库在程序员移动类对象时认为可能会抛出异常
  - 移动操作不抛出异常，但是抛出异常是允许的
  - 标准库**容器**能在异常发生时提供保障，如vector容器push_back异常，vector自身不会改变
  - 在移动过程中抛出异常
    - 可能导致旧元素以改变，新元素为构造的情况
    - 为了避免这种问题，vector除非知道在使用移动构造函数过程中不会抛出异常，  
      否则在重新分配内存过程中, 他就使用**拷贝构造函数**而不是**移动构造函数**
    - 容器，如vector，在重新分配内存过程中，需要对对象元素进行移动而不是拷贝就必须显式告诉标准库，  
      自定义的移动构造函数可以安全使用, 通过noexcept来实现这一点