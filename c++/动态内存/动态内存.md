# 动态内存

- 头文件memory
- 相关内容包括shared_ptr, unique_ptr, new, delete
- 相关概念
  - 静态内存: 存储**static对象**，**类static成员**，**定义在任何函数之外的变量**
  - 栈内存: 用来保存定义在**函数内的非static对象**
  - 堆: 自由空间

## shared_ptr类

- 由新的标准库提供的一种管理动态内存的方法
- 智能指针的一种
- 是一种模板
- [相关操作](#smartpointer)
- make_shared&lt;T&gt;(args)标准库函数
  - 最安全的分配和使用动态内存的方法
  - args对应类型T的构造函数的参数
  - 类似顺序容器的emplace成员
- shared_ptr有关联计数
  - 当一个shared_ptr被拷贝，计数器递增
  - 当一个shared_ptr被赋值或销毁，计数器递减
- 通过析构函数或**自定义操作**销毁
  [[算法函数的可调用表达式参数]]
- get成员函数是为了向不能使用智能指针的代码传递一个**内置**指针，不要使用get为另一个智能指针赋值, 虽然编译器不会报错
- **智能指针**可以确保在程序发生异常时资源被正确释放
- 对于没有析构函数的类可以通过shared_ptr来释放对象`shared_ptr<T> p(p1, deletefunc);`
- 智能指针使用基本规范
  - 不使用相同的内置指针初始化多个智能指针
  - 不delete get()返回的指针
  - 不使用get()初始化或reset另一个智能指针
  - 如果使用了get()返回的指针，当最后一个对应的智能指针销毁后，指针就变为无效
  - 如果使用智能指针管理的资源不是new分配的内存，记得传递给它一个删除器
  
  ```c++
  struct destination;
  struct connection;
  connection connect(destination*)
  void disconnect(connection);
  void end_connection(connection *p) {
      disconnect(*p);
  }
  void f(destination &d)
  {
      connection c = connect(&d);
      shared_ptr<connection> p(&c, end_connection)
  }
  ```

## <span id="newobj">直接管理内存</span>

- 通过**new**分配内存, 赋值给**指针**
  - `int *p = new int;`,默认初始化,*p值未定义,p指向int类型
  - `int *p = new int();`, 值初始化，*p值为0
  - `string *ps = new string(10, '9');`, 直接初始化
  - `vector<int> *pv = new vector<int>{0, 1, 2, 3};`, 列表初始化
  - `auto *pi = new auto(obj);`, 用auto推断我们想要分配的类型
  - new将内存分配和对象构造组合在一起, 区别于allocate
- 定位new , 外观`new (arguments) int`,可以向new传递参数
- delete释放内存
  - 接受一个指向待销毁对象**指针**
  - const对象不能被改变，但可以被销毁
  - delete将对象析构和内存释放结合在一起
- new分配的内存在手动delete释放之前一直存在,即使已经离开作用域
- 使用new和delete管理动态内存的常见问题
  - 忘记用delete释放内存， 通常在程序运行很长时间后,内存耗尽时才被发现
  - 使用以释放掉的对象
  - 同一块内存释放两次，比如有两个指针指向相同动态内存，delete一个后，delete另一个
- 只使用智能指针可避免这些问题
- delete后一个指针变为**空悬指针**, 和未初始化指针有相同的缺点，被访问会引起bug

```c++
int *p = new (nothrow) int;  // 如果分配失败返回空指针
```

## shared_ptr和new结合使用

- 使用new创建的指针初始化一个**shared_ptr**类型指针，必须使用**直接初始化**([通过转换构造函数](#constructfunc))
- 不能进行内置指针到智能指针的隐式转换,通过[转换构造函数](#construncfunc)定义的隐式转换规则实现

```c++
void process(shared_ptr<int> ptr)
{
    /// function_body
}
int *x(new int(1024));  // 用new手动分配内存个x，危险行为
process(x);  // x是一个不同指针，process是函数，未定义普通指针到shared_ptr的转换
process(shared_ptr<int>(x));  // 合法的，但内存会被释放
// 定义的临时shared_ptr和普通指针x指向同一对象
// 函数结束释放临时对象，x编程空悬指针
int j = *x;  // x是空悬指针
```

## unique_ptr

- 只能有一个unique_otr指向给定对象,所以不支持拷贝或赋值
  - [例外](#objmove)，可以拷贝或赋值一个将要被销毁的unique_ptr

  ```c++
  unique_ptr<int> clone(int p) {
      return unique_ptr<int>(new int(p));
  }
  unique_ptr<int> clone(int p) {
      unique_ptr<int> ret(new int (p));
      return ret;
  }
  /// 编译器可以推断出返回的对象将要被销毁，编译器执行一种特殊拷贝
  ```

- 必须直接初始化
- release成员返回当前指针，并释放当前指针,通常用于初始化当前指针或给另一个指针赋值

## weak_ptr

- 指向一个由shared_ptr控制的对象, 不会改变shared_ptr的计数，shared_ptr对象被销毁，weak_ptr一同被销毁
- weak_ptr要用shared_ptr来初始化

## 动态数组

- `int *p = new int[42];`, 得到p是一个指向int的动态数组
- 不是一个真正的数组对象,是指向元素类型的指针
- 初始化
  - 值初始化
  - 列表初始化
- [标准库allocator类](allocator类.md)
  - 按元素个数分配空间的一种方法
  - 头文件memory
  - 将分配内存和对象构造分离，避免浪费
  - 分配的内存是原始的，未构造的
  - 成员[allocate](https://zh.cppreference.com/w/cpp/memory/allocator/allocate)分配而不构造
  - 成员construct构造对象
  - 成员destory销毁对象，接受一个析构函数指针
  - 成员deallocate释放内存
  - [allocator算法函数](#allocatoralgorithm)
