# 构造函数

- 没有返回类型
- 不能声明为const
- 可以有多个构造函数,多个构造函数之间必须有参数数量或类型上的区别
- 构造函数的结构
  - 类名
  - 参数列表
  - 构造函数初始值列表
  - 函数体
- 合成默认构造函数  
  - 只适用于非常简单的类
  - 由编译器创建的构造函数
  - 有初始值使用初始值来初始化，否则默认初始化
  - 通过增加`classtype() = default;`,表示默认构造函数和其他形式的构造函数共存，否则编译器不会自动合成默认构造函数
    - 类内默认内联
    - 类外默认不是内联
- 委托构造函数

  ```c++
  class Sales_data{
      public:
      Sales_data(std::strings, unsinged cnt, double price):
          bookNo(s), units_sold(cnt), revenue(cnt*price) {}
      Sales_data(): Sales_data(" ", 0, 0){}  // 委托构造函数
  }
  ```

- 类外定义构造函数，和其他成员一样，通过作用域操作符说明属于哪个类

## 转换构造函数

  - <u>定义了</u>转换为此类型的隐式转换机制, **一种只接受一个实参的构造函数**
  - 把构造函数声明成**explicit**可以阻止这种隐式转换
  - **隐式类型**转换只允许一步类型转换
  - 正确: "999" $\longrightarrow$ string $\longrightarrow$ Sales_data
  - 错误："999" $\longrightarrow$ Sales_data
  - c++定义了几种内置类型之间的自动转换的规则

## 默认构造函数

- 类必须包含一个构造函数
- 当对象被**默认初始化**或**值初始化**时自动执行**默认构造函数**
- 默认初始化发生情况
  - 当块作用域内不适用任何初始值定义一个非静态变量或数组时
  - 当一个类本身含有类类型的成员且使用合成的默认构造函数时
  - 当类类型的成员没有在构造函数初始值列表中显示初始化时
- 值初始化发生情况
  - 数组初始化的过程中如果提供的初始值数量少于数组的大小
  - 当不使用初始值定义一个局部变量时
  - 当通过形如T()表达式显式地请求值初始化时, 其中T是类型名


```c++
vector<int> v1(10);  // 正确
vector<int> v2 = 10;  // 错误：接受大小参数的构造函数时explicit的
void f(vector<int>);  // 拷贝初始化
f(10);  // 错误：不能用explicit的构造函数拷贝一个实参
f(vector<int>(10));  // 正确：从一个int直接构造一个临时vector
```
